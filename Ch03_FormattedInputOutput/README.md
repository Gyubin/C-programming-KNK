# Chapter 3. Formatted Input/Output

## 1. printf

- `%m.pX`
    + m은 **minimum field with**
    + p는 **precision**
    + X는 **conversion specifier**로 타입을 나타내는 문자
- `m`을 음수로 - 붙여서 적으면 반대쪽이 채워진다.
- p로 표현 칸을 제한하면 반올림해서 숫자 표현된다.

### 1.1 %d

- `%5d` : 최소 5칸을 차지하도록 프린트하라는 의미고 5가 m이다.
    + 123을 프린트하면 `__123` 처럼 되고(언더바는 공백 의미)
    + 123456을 프린트하면 `123456` 처럼 그냥 그만큼 추가로 프린트된다.
- `%-5d` : 123 프린트하면 `123__` 형태로 출력됨.
- `%.5d` : 123 프린트하면 `00123` 형태로 출력. 즉 default p 값은 1이다.

### 1.2 %e

- `%.3e` : float 타입을 e 승수 표현법으로 출력하고 p default 값은 6이다.
- `%e` : 123.45 프린트하면 `1.234500e+02` 형태로 출력
- `%.2e` : 123.45 프린트하면 `1.23e+02` 형태로 출력
- m 부분 역시 같은 의미로 작동

### 1.3 %f

- m, p가 역시 똑같은 의미로 동작한다.
- `%20.6f` : 1234.5678 출력하면 예상하는 것처럼 `________1234.567800` 형태로 출력된다. 앞의 언더바는 공백을 의미하고 개수를 맞추진 않았는데 전체길이 20에 맞춰서 채워진다.

### 1.4 %g

- X가 e 또는 f 로 적절히 선택되어서 표현된다.
- `m.pX` 꼴에서 어떤 숫자가 대입됐을 때 그 숫자의 significant digits(정수 부분)이
    + p보다 크면 X가 `e` 형태로 표현되고
    + p보다 작으면 X가 `f` 형태로 표현된다.
- f와 다르게 g는 trailing zeros가 없다.

## 2. scanf

```c
#include <stdio.h>

int main(void)
{
    int i, j;
    float x, y;
    
    scanf("%d%d%f%f", &i, &j, &x, &y);
    printf("%d %d %f %f\n", i, j, x, y);
    return 0;
}
```

- 위처럼 scanf 안에서 `%d%d%f%f`를 붙여써도 된다.
- 입력할 때 숫자 사이에 white space나 개행문자같은 것을 얼마든지 넣어도 scanf는 하나의 구분으로 생각하고 알아서 잘 구분해준다. 예를 들어 입력을 다음처럼 하는 경우다. `1      2  .3  -4.0e3`
- scanf가 보는 문자
    + `+` or `-`
    + 연속된 숫자(중간에 `.` 들어갈 수 있음)와 뒤따르는 `e` 표현방식
- 만약 scanf가 `%d%d%f%f` format으로 입력을 받고, `1-20.3-4.0e3` 으로 쭉 붙여서 입력한다면 4개 변수에 잘 입력된다.
    + 처음 정수를 받으므로 1까지 읽고 -는 포함될 수 없으므로 거기서 끊는다.
    + 두 번째 정수는 -부터 읽고, 20까지 읽는데 그 다음에 .이 포함될 수 없으므로 끊는다.
    + .3까지 읽고 뒤에 -가 붙을 수 없으므로 끊는다.
    + -4.0e3 남은 숫자 전체 쫙 읽는다.
    + 만약에 입력에서 -4.0e3 뒤에 뭔가 다른 끊겨야하는 문자들이 포함된다면 이후는 싹 무시한다.

### 2.1 패턴 매칭

- format string에서 white-space characters 만날 때
    + **input string**에서 한 개 또는 그 이상의 연속된 white space characters를 만나면 non white space characters(put back이라고 함)를 만날 때까지 계속 읽어들인다.
    + **format string**에서 한개의 white space는 몇 개든지 받아들인 모든 white space와 매칭된다. white space가 없는 것도 포함.
    + **format string**에서 몇 개의 white space를 입력했든 간에 꼭 입력할 때 white space를 포함해야한다는 것은 아니다.
- format string에서 non-white-space characters 만날 때
    + 바로 다음 **input character**를 읽어들이고 **format string**의 문자와 같은지 비교
    + 다르면 바로 abort하고 이후 모든 입력 받는거 종료. 다만 다음 scanf에서 자동으로 나머지가 입력으로 들어간다.
- `%d/%d` 예제(언더바(`_`)는 공백 의미)
    + `10/20` : 정상 작동
    + `____10/20` : 정상 작동
    + `____10/____20` : 정상 작동
    + `____10__/____20` : 비정상 작동. 10만 정상으로 들어감. 문제 상황은 저기 `/` 앞의 공백이 문제다. `%d`를 만났을 때 공백을 쭉 읽어들이다가 10을 만나고 읽어들임. 그리고 format string에서 `/`을 만나는데 바로 다음 input을 읽어들였을 때 white space이기 때문에 서로 달라서 바로 abort 해버린다.
- `%d /%d` : 이렇게 하면 위의 비정상작동 문제 케이스를 해결할 수 있다.
